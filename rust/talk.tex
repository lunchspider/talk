\documentclass{beamer}

% Theme selection

% Packages
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}

% Presentation metadata
\title{The fault in our traits}
\subtitle{\& the borrow checker}
\author{Aman Sharma}
\institute{Aftershoot Inc.}
\date{\today}


\begin{document}

% Title slide
\frame{\titlepage}

\section{Introduction}

\begin{frame}
    Culling is selecting of ?good? images.
    The definition of good/bad is judged by multiple factors, but for the sake of this 
    presentation we take every image, then run ML models on them get scores, and run 
    algorithm on them to get selection/rejections.
\end{frame}


\begin{frame}
    A general overview of culling pipeline would look something this, different pipeline have 
    difference in the steps in between, but the overall overview will look like this
    \begin{center}
    \includegraphics[width = 4cm]{culling_pipeline.jpg}
    \end{center}
\end{frame}

\begin{frame}
    Now how would you encode this into a trait based system?
    Let's start with an image:
    \begin{center}
    \includegraphics[width = 10cm]{partial_image.jpg}
    \end{center}
\end{frame}

\begin{frame}
    Now how would you share this structure across pipeline
    \begin{center}
    \includegraphics[width = 10cm]{partial_image_cnstr.jpg}
    \end{center}
\end{frame}

\begin{frame}
    Now you must do it again with the faces
    \begin{center}
    \includegraphics[width = 10cm]{partial_face.jpg}
    \end{center}
\end{frame}


\begin{frame}
    Faces need to be shared among pipeline right?
    \begin{center}
    \includegraphics[width = 10cm]{partial_face_cnstr.jpg}
    \end{center}
\end{frame}

\begin{frame}
    now can we write any code about the real logic?
\end{frame}

\begin{frame}
    There are some scores that are dependent on duplicate detection, after which selection runs,
    to encode this into the type system, we must create another type for image.
    \includegraphics[width = 10cm]{complete_image.jpg}
\end{frame}


\begin{frame}
    lets add a trait so we can share this across pipeline
    \includegraphics[width = 10cm]{partial_image_filler.jpg}
\end{frame}



\begin{frame}
    This in term made very brittle and hard to reason about, any change and addition
    to the feature or code required writing something horrendeous like this, or simply 
    use a dozen of macros and work in together.
\end{frame}

\begin{frame}
    \begin{center}
    \includegraphics[width = 10cm]{traits_maximus.jpg}
    \end{center}
\end{frame}

\begin{frame}
    Even with the macros, composing features was difficult
     it is *also* because of the how quickly changes were made in the pipeline, and also basically
     the issue being of data drilling, as in data that is created on end of a program is required on 
     the other end of program, also testing was impossible.
\end{frame}

\begin{frame}
    The core reason of creating any time of encapsulation is to have less code duplication,
    traits are good for code generation.
\end{frame}

\begin{frame}
    But they force you to think in term of little small pieces of data/methods, that can be accessed
    from within the traits. this severly restricts with what a computer can do, it primarily restricts things that look
    at two ?random? pieces of data, that might not have any explicit relationship in the domain model
    but an implicit relationship at runtime, this puts a bizzare restrictioin on a given software.
    that is how if you want to do things within an pipeline, everything works fine-ish, but accross
    even the same logic need to respresented again and again.
\end{frame}

\begin{frame}
    What's the solution??
    % IG not shooting ourself in the foot with needlesly encoding domain model 
\end{frame}

\begin{frame}
    We can flip the encapsulation boundary around the feature(s) and not the domain model itself.
\end{frame}

\begin{frame}
    instead of having traits that define methods and GATs, we directly do the thing that we want to do.
\end{frame}

\begin{frame}
    \includegraphics[width = 10cm]{new_structure_example.jpg}
\end{frame}

\begin{frame}
    this kind of similar to how a ECS would work, this makes the code easy to reason about, and this kind of
    encapsulation should not bottleneck the application development.
\end{frame}

\begin{frame}
    Rust was created as a replacement of CPP.
    "Compile-time hiearchy of encapsulation that matches the domain model" - Casey Muratori
    % This dicates the boundaries of code.
    % Some type of encapsulation makes one type fo code easy to write and one type of code
    % harder to write.
\end{frame}

\end{document}
