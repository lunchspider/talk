\documentclass{beamer}

% Theme selection

% Packages
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}

% Presentation metadata
\title{The fault in our traits}
\subtitle{\& the borrow checker}
\author{Aman Sharma}
\institute{Aftershoot Inc.}
\date{\today}


\begin{document}

% Title slide
\frame{\titlepage}

\section{Introduction}

\begin{frame}
    Rust was created as a replacement of CPP.
    "Compile-time hiearchy of encapsulation that matches the domain model" - Casey Muratori
    % This dicates the boundaries of code.
    % Some type of encapsulation makes one type fo code easy to write and one type of code
    % harder to write.
\end{frame}

\begin{frame}
    Now I was trying to create an encapsulation of domain model into traits.
    %That caused too much issue.
\end{frame}

\begin{frame}
    Culling is selecting of ?good? images.
    The definition of good/bad is judged by multiple factor, but for the sake of this 
    presentation we take every image, then run ML models on them get scores, and run 
    algorithm on them to get selection/rejections.
\end{frame}


\begin{frame}
    a smallest \& wrong diagram of our code structure looks like this,
    remind you this is of only one pipeline, each pipeline has a seperate
    structure like this, this causes massive code duplication.
    \begin{center}
        \includegraphics[width = 10cm]{structure.jpg}
    \end{center}
\end{frame}

\begin{frame}
    This in term made very brittle and hard to reason about, any change and addition
    to the feature or code required writing something horrendeous like this, or simply 
    use a dozen of macros and work in together.
\end{frame}

\begin{frame}
    \begin{center}
    \includegraphics[width = 10cm]{traits_maximus.jpg}
    \end{center}
\end{frame}

\begin{frame}
    Even with the macros, composing features was difficult
    % it is *also* because of the changes in the pipeline, with basically
    % the issue being of data drilling, also testing was also impossible.
\end{frame}

\begin{frame}
    The core reason of creating any time of encapsulation is to have less code duplication,
    traits are good for code generation.
\end{frame}

\begin{frame}
    But they force you to think in term of little small pieces of data/methods, that can be accessed
    from within the traits
    % this severly restricts with what a computer can do, it primarily restricts things that look
    % at two ?random? pieces of data, that might not have any explicit relationship in the domain model
    % but an implicit relationship at runtime, this puts a bizzare restrictioin on a given software.
\end{frame}

\begin{frame}
    What's the solution??
    % IG not shooting ourself in the foot with needlesly encoding domain model 
\end{frame}

\begin{frame}
    We can flip the encapsulation boundary around the feature(s) and not the domain model itself.
\end{frame}

\begin{frame}
    instead of having traits that define methods and GATs, we directly do the thing that we want to do.
\end{frame}

\begin{frame}
    \includegraphics[width = 10cm]{new_structure_example.jpg}
\end{frame}

\begin{frame}
    this kind of similar to how a ECS would work, this makes the code easy to reason about, and no 
    encapsulation would never bottleneck the application development.
\end{frame}

\begin{frame}
    So where does borrow checker fit in all of this?
\end{frame}

\begin{frame}
    Well, we tend to think of memory being two kind of memory, stack vs heap
\end{frame}


\end{document}
